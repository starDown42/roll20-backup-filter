<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roll20 í•„í„°ë§</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/style.css" rel="stylesheet">
    <link href="../css/hint.css" rel="stylesheet">
	<script src="https://unpkg.com/prettier@3.0.0/standalone.js"></script>
	<script src="https://unpkg.com/prettier@3.0.0/plugins/html.js"></script>
    <script>
		const prettierConfig = {
			arrowParens: "always",
			bracketSameLine: false,
			objectWrap: "preserve",
			bracketSpacing: true,
			semi: true,
			experimentalOperatorPosition: "end",
			experimentalTernaries: false,
			singleQuote: true,
			jsxSingleQuote: false,
			quoteProps: "as-needed",
			trailingComma: "all",
			singleAttributePerLine: false,
			htmlWhitespaceSensitivity: "css",
			vueIndentScriptAndStyle: false,
			proseWrap: "preserve",
			insertPragma: false,
			printWidth: 9999,
			requirePragma: false,
			tabWidth: 4,
			useTabs: true,
			embeddedLanguageFormatting: "off",
		};
		
        document.addEventListener("DOMContentLoaded", function () {
            const conditions = [
                { name: "ìˆ¨ê¹€ ë©”ì‹œì§€ ì‚­ì œ", deleteType: "hidden" },
                { name: "[PRO] ì‚¬ë‹´ API ì‚­ì œ", deleteType: "etc" },
                { name: "ì „ì²´ ì‚­ì œ", deleteType: "all" }
            ];
            const fileInput = document.getElementById('fileInput');

            const orignCobyButton = document.getElementById("orignCobyButton");
            const resultsContainer = document.getElementById("results");

            const filterButton = document.getElementById("filterButton");
            const journalButton = document.getElementById("journalButton");

			async function filterHtml() {
				const fileInput = document.getElementById('fileInput');
				if (!fileInput.files.length) return alert('HTML íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');

				const reader = new FileReader();
				reader.onload = async function (event) { // âœ… async ì¶”ê°€
					const parser = new DOMParser();
					const oriDoc = parser.parseFromString(event.target.result, 'text/html');

					// ğŸ”¹ Prettierë¥¼ ì´ìš©í•œ í¬ë§·íŒ…
					const formattedHtml = await prettier.format(event.target.result, { // âœ… await ì •ìƒ ì ìš©
						parser: "html",
						plugins: [prettierPlugins.html],
						...prettierConfig, // âœ… ì»¤ìŠ¤í…€ ì„¤ì • ì ìš©
					});

					// ğŸ”¹ ë‹¤ì‹œ HTMLë¡œ ë³€í™˜ (ì¤‘ìš”!)
					const doc = parser.parseFromString(formattedHtml, 'text/html');

						conditions.forEach(cond => {
							let deleteTargets = [];
							if (cond.deleteType === "hidden") {
								deleteTargets.push(...doc.querySelectorAll("div.message.hidden-message"));
							} else if (cond.deleteType === "etc") {
								doc.querySelectorAll("div.message span[style='color: #aaaaaa']").forEach(span => {
									let parentMessage = span.closest("div.message");
									if (parentMessage) deleteTargets.push(parentMessage);
								});
							} else if (cond.deleteType === "all") {
								deleteTargets.push(...doc.querySelectorAll("div.message.hidden-message"));
								doc.querySelectorAll("div.message span[style='color: #aaaaaa']").forEach(span => {
									let parentMessage = span.closest("div.message");
									if (parentMessage) deleteTargets.push(parentMessage);
								});
							}

							deleteTargets = deleteTargets.filter(el => {
								if (!el.querySelector("div.avatar")) {
									el.remove();
									return false;
								}
								return true;
							});

							deleteTargets.forEach(A => {
								let B = A.nextElementSibling;
								if (!B || !B.classList.contains("message")) return;

								if (A.querySelector("div.avatar")) {
									if (B.querySelector("div.avatar")) {
										A.remove();
									} else {
										["div.spacer", "div.avatar", "div.tstamp", "div.by"].forEach(cls => {
											A.querySelectorAll(cls).forEach(child => B.prepend(child.cloneNode(true)));
										});
										A.remove();
									}
								} else {
									A.remove();
								}
							});

							let resultTextarea = resultsContainer.querySelector(`textarea[data-type="${cond.deleteType}"]`);
							resultTextarea.value = doc.body.innerHTML;
						});
					alert("í•„í„°ë§ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
                }
                reader.readAsText(fileInput.files[0]);
            }

            async function extractJournalFormat() {
				const fileInput = document.getElementById('fileInput');
				if (!fileInput.files.length) return alert('HTML íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');

				const reader = new FileReader();
				reader.onload = async function (event) { // âœ… async ì¶”ê°€
					const parser = new DOMParser();
					const oriDoc = parser.parseFromString(event.target.result, 'text/html');

					// ğŸ”¹ Prettierë¥¼ ì´ìš©í•œ í¬ë§·íŒ…
					const formattedHtml = await prettier.format(event.target.result, { // âœ… await ì •ìƒ ì ìš©
						parser: "html",
						plugins: [prettierPlugins.html],
						...prettierConfig, // âœ… ì»¤ìŠ¤í…€ ì„¤ì • ì ìš©
					});

					// ğŸ”¹ ë‹¤ì‹œ HTMLë¡œ ë³€í™˜ (ì¤‘ìš”!)
					const doc = parser.parseFromString(formattedHtml, 'text/html');
                
                    let output = [];
                    let descBuffer = '';
                    let emoteBuffer = ''; // emoteë¥¼ ìœ„í•œ ë²„í¼ ì¶”ê°€
                    
                    doc.querySelectorAll('.textchatcontainer .content .message').forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('message')) {
                            // .desc í´ë˜ìŠ¤ ì²˜ë¦¬
                            if (node.classList.contains('desc')) {
                                descBuffer += (descBuffer ? ' ' : '') + node.innerText.trim(); // .desc ë‚´ìš© ë³‘í•©

                                    // .emoteê°€ ìˆìœ¼ë©´ ë¨¼ì € ì¶œë ¥í•˜ê³ , ëŒ€ì‚¬ë¥¼ ì¶œë ¥
                                    if (emoteBuffer) {
                                        output.push(`\n${emoteBuffer}`); // .emoteëŠ” ë§¨ ì•ì— \n ì¶”ê°€
                                        emoteBuffer = ''; // emoteBuffer ì´ˆê¸°í™”
                                    }
                            } 
                            // .emote í´ë˜ìŠ¤ ì²˜ë¦¬
                            else if (node.classList.contains('emote')) {
                                emoteBuffer += (emoteBuffer ? ' ' : '') + node.innerText.trim(); // .emote ë‚´ìš© ë³‘í•©

                                // .descê°€ ìˆìœ¼ë©´ ë¨¼ì € ì¶œë ¥í•˜ê³ , ëŒ€ì‚¬ë¥¼ ì¶œë ¥
                                if (descBuffer) {
                                    output.push(`\n${descBuffer}`); // .descëŠ” ë§¨ ì•ì— \n ì¶”ê°€
                                    descBuffer = ''; // descBuffer ì´ˆê¸°í™”
                                }
                            }
                            else {
                                // ë‹¤ë¥¸ ë©”ì‹œì§€ ì²˜ë¦¬ (ì‘ì„±ìì™€ ëŒ€ì‚¬ ë¶€ë¶„)
                                const authorNode = node.querySelector('.by');
                                const author = authorNode ? authorNode.textContent.trim() : '';

                                const sheetRollNode = node.querySelector('[class*="sheet-rolltemplate"]');
                                if (sheetRollNode) {
                                    let rollTemplateText = '';

                                    // ëª¨ë“  ìì‹ ë…¸ë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ ê²€ì‚¬
                                    function extractTextFromChildNodes(parentNode) {
                                        Array.from(parentNode.childNodes).forEach(childNode => {
                                            if (childNode.nodeType === Node.TEXT_NODE && childNode.textContent.trim()) {
                                                rollTemplateText += (rollTemplateText ? ' ' : '') + childNode.textContent.trim();
                                            } else if (childNode.nodeType === Node.ELEMENT_NODE) {
                                                extractTextFromChildNodes(childNode);  // ìì‹ ë…¸ë“œê°€ ìˆìœ¼ë©´ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬
                                            }
                                        });
                                    }

                                    // í…ìŠ¤íŠ¸ ì¶”ì¶œ ì‹œì‘
                                    extractTextFromChildNodes(sheetRollNode);
                                    
                                    // ì‘ì„±ìê°€ ìˆì„ ê²½ìš°
                                    if (author) {
                                        output.push(`\n${author}:[ì €ë„ëª…]\t${rollTemplateText}`);
                                    } else {
                                        // ì‘ì„±ìê°€ ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥í•˜ë˜, íŒì •ì˜ ê²½ìš° \nì„ ì¶”ê°€í•¨.
                                        output.push(`${rollTemplateText}\n`);
                                    }
                                } else {
                                    const textNode = Array.from(node.childNodes)
                                        .filter(n => n.nodeType === Node.TEXT_NODE)  // í…ìŠ¤íŠ¸ ë…¸ë“œë¥¼ í•„í„°ë§
                                        .map(n => n.nodeValue.trim())  // í…ìŠ¤íŠ¸ ê°’ë§Œ ê°€ì ¸ì˜¤ê¸°
                                        .filter(n => n !== '');  // ë¹ˆ í…ìŠ¤íŠ¸ëŠ” ì œì™¸
                                    
                                    // ì²« ë²ˆì§¸ í…ìŠ¤íŠ¸ëŠ” ëŒ€ì‚¬ê°€ ì•„ë‹ˆë¯€ë¡œ ë‘ ë²ˆì§¸ í…ìŠ¤íŠ¸ë¶€í„° ëŒ€ì‚¬ë¡œ ì‚¬ìš©
                                    const text = textNode.length > 1 ? textNode.slice(1).join(' ') : textNode[0] || '';
                                    
                                    // .descê°€ ìˆìœ¼ë©´ ì¶œë ¥í•˜ê³ , ëŒ€ì‚¬ë¥¼ ì¶œë ¥
                                    if (descBuffer) {
                                        output.push(`\n${descBuffer}`);
                                        descBuffer = ''; // descBuffer ì´ˆê¸°í™”
                                    }
                                    
                                    // .emoteê°€ ìˆìœ¼ë©´ ì¶œë ¥í•˜ê³ , ëŒ€ì‚¬ë¥¼ ì¶œë ¥
                                    if (emoteBuffer) {
                                        output.push(`\n${emoteBuffer}`);
                                        emoteBuffer = ''; // emoteBuffer ì´ˆê¸°í™”
                                    }

                                    // ì‘ì„±ìê°€ ìˆì„ ê²½ìš°
                                    if (author) {
                                        output.push(`\n${author}:[ì €ë„ëª…]\t${text}`);
                                    } else {
                                        // ì‘ì„±ìê°€ ì—†ìœ¼ë©´ ê·¸ëƒ¥ í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥
                                        output.push(text);
                                    }
                                }
                            }
                        } else if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {
                            // í…ìŠ¤íŠ¸ ë…¸ë“œê°€ ìˆë‹¤ë©´ ê·¸ ìì²´ë¥¼ ì¶œë ¥
                            if (descBuffer) {
                                output.push(`\n${descBuffer}`);
                                descBuffer = ''; // ì´ˆê¸°í™”
                            }
                            if (emoteBuffer) {
                                output.push(`\n${emoteBuffer}`);
                                emoteBuffer = ''; // ì´ˆê¸°í™”
                            }
                            output.push(node.nodeValue.trim());
                        }
                    });

                    // .desc ë©”ì‹œì§€ê°€ ë§ˆì§€ë§‰ì— ë‚¨ì•„ ìˆë‹¤ë©´ ì¶œë ¥
                    if (descBuffer) {
                        output.push(`\n${descBuffer}`);
                    }
                    
                    // .emote ë©”ì‹œì§€ê°€ ë§ˆì§€ë§‰ì— ë‚¨ì•„ ìˆë‹¤ë©´ ì¶œë ¥
                    if (emoteBuffer) {
                        output.push(`\n${emoteBuffer}`);
                    }

                    document.getElementById("journalResult").value = output.join("\n");
                    alert("í…ìŠ¤íŠ¸ ì¶”ì¶œì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
                }
                reader.readAsText(fileInput.files[0]);
            }

            filterButton.addEventListener("click", filterHtml);
            journalButton.addEventListener("click", extractJournalFormat);
            createResultFields();
        });
    </script>
</head>
<body class="container py-4">
	<header>
		<h2 class="pt-4 text-center">
			<a class="hometitle" href="../index.html">ORPG ë°±ì—… ì„œí¬íŠ¸</a>
		</h2>
		<hr class="my-4">
	</header>

    <main>
		<div class="title">
            <h3 class="mb-3 fw-bold">ğŸ“„ Roll20 ë°±ì—…ìš© í›„ê°€ê³µ</h3>
            <hr class="my-4">
        </div>
    
        <div>
            <button id="filterButton" class="btn btn-primary ms-2 float-end">ë¶ˆí•„ìš” ë©”ì‹œì§€ ì‚­ì œ</button>
            <button id="journalButton" class="btn btn-success ms-2 float-end">í…ìŠ¤íŠ¸ ì¶”ì¶œ</button>

            <h4 class="mb-3" id="title">HTML íŒŒì¼ ì—…ë¡œë“œ</h4>
            <input type="file" id="fileInput" accept=".html" class="form-control mb-3">
            
            <div id="option_wrap" class="mb-3"><form id="option_form">
				<div class="form-check form-check-inline pointer">
					<input class="form-check-input" type="checkbox" id="remove_hidden_message">
					<label class="form-check-label  hint--top" for="remove_hidden_message" aria-label="This message is hidden ì œê±°">
						hidden ì œê±°
					</label>
				</div>
				
				<div class="form-check form-check-inline pointer">
					<input class="form-check-input" type="checkbox" id="dot_to_ellipsis">
					<label class="form-check-label hint--top" for="dot_to_ellipsis" aria-label="ì˜¨ì  3ê°œ ë‹¨ìœ„ > 2ê°œ ì”ì—¬ ì²˜ë¦¬">
						ë§ì¤„ì„í‘œ ë³€ê²½ [... -> â€¦ ]
					</label>
				</div>

				<div class="form-check form-check-inline pointer">
					<input class="form-check-input" type="checkbox" id="remove_prv_api_message">
					<label class="form-check-label  hint--top" for="remove_prv_api_message" aria-label="ì‚¬ë‹´ API(! í•  ë§, ì–‘ì¼ì²œì—¼ ë‹˜ ë°°í¬) ë¡œ ì¶œë ¥ëœ ëŒ€ì‚¬ ì‚­ì œ">
						[PRO] ì‚¬ë‹´ API ì œê±°
					</label>
				</div>
			</form></div>
        </div>
        <hr class="my-4 mb-3">

        <section id="filter-result-wrap" class="py-4 px-4 border-0 rounded bg-primary bg-opacity-50 text-white">
            <div class="mb-3">
				<h5 class="mb-3">ë¶ˆí•„ìš” ë©”ì‹œì§€ ì‚­ì œ ê²°ê³¼ <small id="filterOutputLength"></small></h5>
				<div class="d-flex align-items-stretch">
					<textarea id="filter-output" class="form-control textarea-box" readonly="true" data-type="hidden"></textarea>
					<button id="btn_filter-output-copy" class="btn btn-dark ms-2">ğŸ“‹</button>
				</div>
			</div>
        </section>

        <section id="journal-result-wrap" class="mt-4 py-4 px-4 border-0 rounded bg-success bg-opacity-50 text-white">
            <div class="mb-3">
				<h5 class="mb-3">í…ìŠ¤íŠ¸ ì¶”ì¶œ ê²°ê³¼ <small id="outputLength"></small></h5>
				<div class="d-flex align-items-stretch">
					<textarea id="output" class="form-control textarea-box" readonly="true" data-type="hidden"></textarea>
					<button id="btn_output-copy" class="btn btn-dark ms-2">ğŸ“‹</button>
				</div>
			</div>

			<div class="my-4 mb-3">
				<h5 class="mb-3">ì €ë„ë³„ ëŒ€ì‚¬ ì¶”ì¶œ ê²°ê³¼ <small id="journalOutputLength"></small></h5>
				<div class="d-flex">
					<textarea id="journalOutput" class="form-control textarea-box"></textarea>
					<div class="ms-2 w-25">
						<select id="journalSelect" class="form-select"><option value="0">-</option></select>
						<button id="btn_journalTxtCopy" class="btn btn-dark mt-2 w-100">ğŸ“‹</button>
					</div>
				</div>
			</div>
        </section>
        

    </main>
</body>
</html>
